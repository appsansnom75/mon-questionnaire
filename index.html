<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Questionnaire Adaptatif</title>
<style>
body { font-family: Arial, sans-serif; max-width: 600px; margin: auto; padding: 20px; }
h2 { color: #333; }
button { margin: 5px; padding: 10px 20px; font-size: 16px; cursor: pointer; }
input { padding: 5px; font-size: 16px; margin-right: 10px; }
</style>
</head>
<body>
<h2 id="title">Questionnaire</h2>
<div id="question">Chargement…</div>

<script type="module">
// ----- Supabase setup (frontend safe) -----
// Note : Clé secrète ne doit pas être exposée, ici on teste fetch public
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

const supabaseUrl = 'https://xlncdpwghwqorjgkuecu.supabase.co'
const supabase = createClient(supabaseUrl, '') // clé vide = lecture publique

const WORKER_URL = "https://compatibility-worker.appsansnom.workers.dev/";

// ----- Variables -----
let questions = [];
let asked = [];
let answers = [];
let scores = {};
let current = null;

// ----- Charger les questions -----
// Pour tester : on utilise des données simulées si Supabase n’est pas accessible
async function loadQuestions() {
  try {
    // fetch réel depuis Supabase (si tables publiques)
    // const { data, error } = await supabase.from('questions').select('*');
    // if (error) throw error;
    // questions = data;

    // Données simulées pour test local
    questions = [
      { id: 1, text: "Aimes-tu le chocolat ?", type: "yesno", options: ["Oui","Non"], dimension: "gout", trigger_rule: "always" },
      { id: 2, text: "Es-tu plutôt matin ou soir ?", type: "choices", options: ["Matin","Soir"], dimension: "rythme", trigger_rule: "always" },
      { id: 3, text: "Combien d'heures dors-tu ?", type: "scale", dimension: "sommeil", response_score_mapping: [0,1,2], trigger_rule: "always" }
    ];

    nextQuestion();
  } catch(e) {
    console.error("Erreur chargement questions", e);
    document.getElementById("question").innerText = "Impossible de charger les questions.";
  }
}

// ----- Vérifie si question éligible -----
function eligible(q) {
  if (asked.includes(q.id)) return false;
  if (!q.trigger_rule || q.trigger_rule === "always") return true;
  try {
    const expr = q.trigger_rule.replace(/\b(\w+)\b/g, (_, d) => `(scores["${d}"]||0)`);
    return eval(expr);
  } catch(e) {
    console.error("Erreur trigger_rule question", q.id, e);
    return false;
  }
}

// ----- Afficher question -----
function renderQuestion() {
  const container = document.getElementById("question");
  container.innerHTML = "";

  const qText = document.createElement("p");
  qText.innerText = current.text;
  container.appendChild(qText);

  const mapping = current.response_score_mapping || [];

  if(current.type === "scale") {
    ["Pas du tout","Un peu","Beaucoup"].forEach((label,i) => {
      const score = mapping[i] ?? i;
      const btn = document.createElement("button");
      btn.innerText = label;
      btn.onclick = () => recordAnswer(score);
      container.appendChild(btn);
    });
  } else if(current.type === "yesno" || current.type === "choices") {
    const labels = current.options || ["Oui","Non"];
    labels.forEach((label,i) => {
      const score = mapping[i] ?? i;
      const btn = document.createElement("button");
      btn.innerText = label;
      btn.onclick = () => recordAnswer(score);
      container.appendChild(btn);
    });
  } else if(current.type === "text") {
    const input = document.createElement("input");
    input.type = "text";
    input.id = "textAnswer";
    const btn = document.createElement("button");
    btn.innerText = "Valider";
    btn.onclick = () => recordAnswer(0);
    container.appendChild(input);
    container.appendChild(btn);
  }
}

// ----- Enregistrer réponse -----
function recordAnswer(val) {
  answers.push({ dimension: current.dimension, value: val, weight: current.weight || 1 });
  scores[current.dimension] = (scores[current.dimension] || 0) + val * (current.weight || 1);
  nextQuestion();
}

// ----- Prochaine question -----
function nextQuestion() {
  if (asked.length >= 20 || asked.length >= questions.length) return finish();
  const q = questions.find(eligible);
  if (!q) return finish();
  asked.push(q.id);
  current = q;
  renderQuestion();
}

// ----- Fin du questionnaire -----
async function finish() {
  document.getElementById("title").innerText = "Calcul en cours…";
  document.getElementById("question").innerText = "";

  try {
    // Simuler profil utilisateur
    const MY_PROFILE = { securite: 0.7, autonomie: 0.4 };

    // Envoi au Worker pour compatibilité
    const workerRes = await fetch(WORKER_URL, {
      method: "POST",
      body: JSON.stringify({ action: "profile", answers })
    });
    const profile = await workerRes.json();

    const compatRes = await fetch(WORKER_URL, {
      method: "POST",
      body: JSON.stringify({ action: "compatibility", me: MY_PROFILE, friend: profile })
    });
    const res = await compatRes.json();

    document.body.innerHTML = `<h2>Compatibilité : ${res.percent ?? 0}%</h2>
      <div id="explanation">Explication simulée...</div>`;

  } catch(e) {
    console.error(e);
    document.getElementById("question").innerText = "Impossible de calculer la compatibilité.";
  }
}

// ----- Lancement -----
loadQuestions();

</script>
</body>
</html>
