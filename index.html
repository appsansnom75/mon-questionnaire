<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Questionnaire Adaptatif</title>
<style>
body { font-family: Arial, sans-serif; max-width: 600px; margin: auto; padding: 20px; }
h2 { color: #333; }
button { margin: 5px; padding: 10px 20px; font-size: 16px; cursor: pointer; }
input { padding: 5px; font-size: 16px; margin-right: 10px; }
</style>
</head>
<body>
<h2 id="title">Questionnaire</h2>
<div id="question">Chargement…</div>

<script type="module">
// ----- Worker URL -----
const WORKER_URL = "https://compatibility-worker.appsansnom.workers.dev/";

// ----- Variables -----
let questions = [];
let asked = [];
let answers = [];
let scores = {};
let current = null;

// ----- Charger les questions depuis le Worker -----
async function loadQuestions() {
  try {
    const res = await fetch(WORKER_URL)
    questions = await res.json()
    if (!Array.isArray(questions) || questions.length === 0) {
      throw new Error("Pas de questions récupérées")
    }
    nextQuestion()
  } catch(e) {
    console.error("Erreur chargement questions", e)
    document.getElementById("question").innerText = "Impossible de charger les questions."
  }
}

// ----- Vérifie si question éligible -----
function eligible(q) {
  if (asked.includes(q.ID)) return false;
  if (!q.trigger_rule || q.trigger_rule === "always") return true;
  try {
    // Exemple simple pour test : ignore les règles complexes pour l'instant
    if (q.trigger_rule.startsWith("score_high") || q.trigger_rule.startsWith("contradiction") || q.trigger_rule.startsWith("priority")) {
      return true; // pour test
    }
    return eval(q.trigger_rule.replace(/\b(\w+)\b/g, (_, d) => `(scores["${d}"]||0)`));
  } catch(e) {
    console.error("Erreur trigger_rule question", q.ID, e)
    return false
  }
}

// ----- Afficher question -----
function renderQuestion() {
  const container = document.getElementById("question")
  container.innerHTML = ""

  const qText = document.createElement("p")
  qText.innerText = questions[current].Question
  container.appendChild(qText)

  const mappingStr = questions[current].response_score_mapping
  const mapping = mappingStr.split('|').map(s => s.trim().split('=')).map(([label,val]) => ({label,val: parseFloat(val)}))

  mapping.forEach(({label, val}) => {
    const btn = document.createElement("button")
    btn.innerText = label
    btn.onclick = () => recordAnswer(val)
    container.appendChild(btn)
  })
}

// ----- Enregistrer réponse -----
function recordAnswer(val) {
  const q = questions[current]
  answers.push({ dimension: q.Dimension, value: val, weight: q.weight || 1 })
  scores[q.Dimension] = (scores[q.Dimension] || 0) + val * (q.weight || 1)
  nextQuestion()
}

// ----- Prochaine question -----
function nextQuestion() {
  if (asked.length >= questions.length) return finish()
  const idx = questions.findIndex((q, i) => i >= asked.length && eligible(q))
  if (idx === -1) return finish()
  asked.push(idx)
  current = idx
  renderQuestion()
}

// ----- Fin du questionnaire -----
async function finish() {
  document.getElementById("title").innerText = "Calcul en cours…"
  document.getElementById("question").innerText = ""

  try {
    const workerRes = await fetch(WORKER_URL, {
      method: "POST",
      body: JSON.stringify({ action: "profile", answers }),
      headers: { "Content-Type": "application/json" }
    })
    const profile = await workerRes.json()

    const compatRes = await fetch(WORKER_URL, {
      method: "POST",
      body: JSON.stringify({ action: "compatibility", me: profile, friend: profile }),
      headers: { "Content-Type": "application/json" }
    })
    const res = await compatRes.json()

    document.body.innerHTML = `<h2>Compatibilité : ${res.percent ?? 0}%</h2>
      <div id="explanation">Explication : ${res.explanation ?? "Non disponible"}</div>`

  } catch(e) {
    console.error(e)
    document.getElementById("question").innerText = "Impossible de calculer la compatibilité."
  }
}

// ----- Lancement -----
loadQuestions()
</script>
</body>
</html>
